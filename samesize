#!/usr/bin/perl 
use 5.014 ; use strict ; use warnings  ;
use feature qw [ say ] ;
use Time::HiRes qw[ stat gettimeofday tv_interval ] ;  # stat をマイクロ秒単位にする。
use Term::ANSIColor qw [ :constants color ] ; $Term::ANSIColor::AUTORESET = 1 ; 
use File::Spec::Functions qw[ catfile splitdir rel2abs updir ] ; 
use Getopt::Std ; 
use List::Util qw [ max min sum sum0 reduce ] ;
use Cwd qw [ getcwd abs_path ] ;
use POSIX qw[ strftime ] ;

use Digest::MD5 qw[ md5 md5_hex md5_base64 ] ; # use Digest::SHA1 qw[ sha1 sha1_hex sha1_base64 ]; 

sub dtwhen ( $ ) ;

my $time_start = [ gettimeofday ] ; 
my $t0 = $time_start -> [0] ;

getopts '2b:Df:l:mnos' , \my%o ; 

my @Files0 = @ARGV ? @ARGV : glob '*' ; # glob '*' はディレクトリのファイルは抽出しない。

if ( $o{D} ) { # -Dは破壊的ゆえ、色々ここで仕込む。↓
  $o{2} = 1 if $o{D} ; # -2 指定で、1番目は表示しない。
  $o{m} = 1 if $o{D} ; # -m 指定で、m5ハッシュ値を計算させる。
} 
& main ; 
exit 0 ;

END{ print RESET "" } ;

sub main () {

  my %s2f ; # %{ $s2f { $size } } でバイトサイズから、ファイル名の一覧を取り出せる。
  for ( @Files0 ) {
  	next if -d $_ ; # ディレクリファイルは、対象外となる。
    next if -l $_ && 0 eq ($o{l}//'') ;  # -l0 を指定すると、シンボリックリンクファイルは、対象外。
  	my $size = ( stat ) [7] ; # <-- - lstat でなくて stat なので、シンボリックリンクのファイルはその先の中身を見る。
  	next if $size <  ( $o{b} // 0 ) ; # 最小のバイトサイズを見たな避ければ、対象外。
  	push @{ $s2f{$size} } , $_ ;
  }

  my $least = $o{f} // 2 ; # 同じバイトサイズが何個以上の場合を対象にするか? 
  my @sizes  = sort { $a<=>$b } grep { @{ $s2f { $_ } } >= $least } keys %s2f ; 
  my $fmt = do { my $t = max @sizes , 0 ; my $d = length "$t" ; "%${d}s" } ; # サイズの数値のフォーマットを"%7d"のように決める。
  for my $size ( @sizes ) { 
  	my @files = sort @{ $s2f{$size} } ; # ファイルの一覧
  	@files = sort {(stat $a)[9] <=> (stat $b)[9] } @files if $o{n} // $o{o} ;
  	@files = reverse @files if $o{n} ;
  	my %seenD ; # 既に見たハッシュダイジェスト値
  	for ( @files ) { 
      my @t3 = ( stat $_ ) [ 8, 9, 10 ] ; # <-- atime, mtime, ctime の 日時3情報
  	  my $ctx = Digest::MD5 -> new ;
  	  if ( $o{m} ) {
  	    open my $FH, '<', $_ or die  "Can't open '$_': $!";
  	    binmode $FH ; 
	      $ctx -> addfile ( $FH );
	      close $FH ;
	    }

	    utime @t3[0,1] , $_ if $o{m} ; # ハッシュ値計算でアクセスしたことでアクセス日時が変わったことを、無かったことにする。
      my $digest = $o{m} ? $ctx -> hexdigest : '---' ;
      next if $o{2} && ! $seenD{ $digest } ++ ;
      do { unlink $_ ; $_ .=  RED "\t<-- removed." } if $o{D} ; 
  	  my @out = ( sprintf ($fmt , $size)  , $digest , map ( dtwhen $_ , @t3 ) , $_ ) ;
  	  say join "\t" , @out ;
  	}
  }
}

sub dtwhen ( $ ) { 
	my $fmt = abs ( $_[0] - $t0 ) >= 86400 * 180 ? '%Y-%m-%d' : $o{s} ? '%m-%d %H:%M:%S' : '%m-%d %H:%M';
	strftime $fmt , localtime $_[0] ;
}

END {
  exit if exists $o{v} && $o{v} eq "0" ;
  say STDERR BOLD FAINT " --  " , " Process time: " ,  " " , 
  sprintf( "%.6f", tv_interval $time_start , [ gettimeofday ] ) , " second(s)." ;
}

## ヘルプの扱い
sub VERSION_MESSAGE {}
sub HELP_MESSAGE {
    use FindBin qw[ $Script ] ; 
    $ARGV[1] //= '' ;
    open my $FH , '<' , $0 ;
    while(<$FH>){
        s/\$0/$Script/g ;
        print $_ if s/^=head1// .. s/^=cut// and $ARGV[1] =~ /^o(p(t(i(o(ns?)?)?)?)?)?$/i ? m/^\s+\-/ : 1;
    }
    close $FH ;
    $o{v} = 0 ;
    exit 0 ;
}

=encoding utf8
=head1

  警告: このコマンドは、ファイルのアクセス時刻情報を書き換えたり、消去したりすることがある。

　$0 files 

  全く同じバイトサイズのファイルを検出する。

 オプション:
   -m : MD5ハッシュ値を算出する。(なお、ファイルのアクセス時刻は変更しない工夫がしてある。)
   -b N : 処理対象とする最小のバイトサイズを指定。0バイトファイルを避けるなら1を指定。
   -f N : 少なくとも何回出現したものだけを取り出すかの指定。初期値は2。
   -l 0 : シンボリックリンクのファイルは、対象外にする。
   -n : 同じファイルサイズなら書換日時の新しい順 (newer)
   -o : 同じファイルサイズなら書換日時の古い順 (older)
   -s : 180日以内について、日時情報は秒単位で表示。

   -2 : 同じファイルサイズで，同じハッシュ値のものについて、2番目以降を取り出す。
   -D : 同じファイルサイズで，同じハッシュ値のものについて、2番目以降をファイル除去する。<-- 破壊的, 危険
